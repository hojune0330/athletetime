<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PC 차트 다운로드 테스트</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body class="bg-gray-100 p-4">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-2xl font-bold mb-6">PC 차트 다운로드 방식 테스트</h1>
    
    <!-- 테스트 설명 -->
    <div class="bg-blue-50 border-l-4 border-blue-500 p-4 mb-6">
      <h2 class="font-bold text-lg mb-2">🎯 테스트 목적</h2>
      <p class="text-sm text-gray-700">
        모바일 페이지에서 PC 버전의 차트를 직접 가져와서 다운로드하는 기능을 테스트합니다.
        <br><br>
        <strong>핵심:</strong> 모바일에서 다운로드 버튼을 클릭하면, 숨겨진 iframe으로 로드된 PC 페이지의 차트를 그대로 가져와서 다운로드합니다.
      </p>
    </div>
    
    <!-- PC iframe (숨김) -->
    <iframe id="pc-frame" src="pace-calculator.html" style="display: none;"></iframe>
    
    <!-- 로딩 표시 -->
    <div id="loading" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div class="bg-white p-6 rounded-lg">
        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto"></div>
        <p class="mt-4 text-center">PC 차트 생성 중...</p>
      </div>
    </div>
    
    <!-- 테스트 버튼들 -->
    <div class="grid grid-cols-2 gap-4 mb-6">
      <button onclick="testDownloadPCChart('chart1', 'png')" 
              class="bg-blue-500 text-white p-4 rounded-lg hover:bg-blue-600">
        <i class="fas fa-image mr-2"></i>
        차트1 PNG 다운로드
        <br><span class="text-xs">(킬로미터 페이스)</span>
      </button>
      
      <button onclick="testDownloadPCChart('chart1', 'pdf')" 
              class="bg-red-500 text-white p-4 rounded-lg hover:bg-red-600">
        <i class="fas fa-file-pdf mr-2"></i>
        차트1 PDF 다운로드
        <br><span class="text-xs">(킬로미터 페이스)</span>
      </button>
      
      <button onclick="testDownloadPCChart('chart2', 'png')" 
              class="bg-green-500 text-white p-4 rounded-lg hover:bg-green-600">
        <i class="fas fa-image mr-2"></i>
        차트2 PNG 다운로드
        <br><span class="text-xs">(목표 기록별)</span>
      </button>
      
      <button onclick="testDownloadPCChart('chart4', 'png')" 
              class="bg-purple-500 text-white p-4 rounded-lg hover:bg-purple-600">
        <i class="fas fa-water mr-2"></i>
        차트4 PNG 다운로드
        <br><span class="text-xs">(3000m 장애물)</span>
      </button>
    </div>
    
    <!-- 결과 표시 -->
    <div id="result" class="bg-white p-4 rounded-lg shadow">
      <h3 class="font-bold mb-2">테스트 결과:</h3>
      <div id="resultContent" class="text-sm text-gray-600">
        아직 테스트를 실행하지 않았습니다.
      </div>
    </div>
    
    <!-- 실제 페이지 링크 -->
    <div class="mt-6 space-y-2">
      <a href="pace-calculator-mobile.html" 
         class="block bg-indigo-500 text-white p-3 rounded-lg text-center hover:bg-indigo-600">
        <i class="fas fa-mobile-alt mr-2"></i>
        수정된 모바일 페이스 계산기 열기
      </a>
      <a href="pace-calculator.html" 
         class="block bg-gray-500 text-white p-3 rounded-lg text-center hover:bg-gray-600">
        <i class="fas fa-desktop mr-2"></i>
        PC 페이스 계산기 열기
      </a>
    </div>
  </div>
  
  <script>
    async function testDownloadPCChart(chartId, format) {
      const loading = document.getElementById('loading');
      const resultContent = document.getElementById('resultContent');
      const pcFrame = document.getElementById('pc-frame');
      
      try {
        // 로딩 표시
        loading.classList.remove('hidden');
        resultContent.innerHTML = `<span class="text-blue-500">다운로드 시작: ${chartId} (${format})</span>`;
        
        // iframe 로드 대기
        await new Promise((resolve) => {
          if (pcFrame.contentDocument?.readyState === 'complete') {
            resolve();
          } else {
            pcFrame.onload = resolve;
            setTimeout(resolve, 2000); // 타임아웃
          }
        });
        
        // PC 문서 접근
        const pcDoc = pcFrame.contentDocument;
        const pcWin = pcFrame.contentWindow;
        
        // 방법 1: PC 페이지의 downloadChart 함수 직접 호출
        if (pcWin && typeof pcWin.downloadChart === 'function') {
          resultContent.innerHTML += '<br>✅ PC의 downloadChart 함수 발견';
          
          const timestamp = new Date().toISOString().slice(0,10).replace(/-/g, '');
          const filename = `테스트_${chartId}`;
          
          await pcWin.downloadChart(chartId, filename, format);
          resultContent.innerHTML += `<br><span class="text-green-500">✅ 다운로드 완료!</span>`;
        } else {
          // 방법 2: 차트 요소 직접 복사
          resultContent.innerHTML += '<br>⚠️ downloadChart 함수 없음, 직접 복사 시도';
          
          const chartElement = pcDoc.getElementById(chartId);
          if (!chartElement) {
            throw new Error('차트를 찾을 수 없습니다');
          }
          
          // 차트 복사 및 다운로드
          await downloadChartDirect(chartElement, chartId, format);
          resultContent.innerHTML += `<br><span class="text-green-500">✅ 직접 다운로드 완료!</span>`;
        }
        
      } catch (error) {
        console.error('다운로드 실패:', error);
        resultContent.innerHTML += `<br><span class="text-red-500">❌ 오류: ${error.message}</span>`;
      } finally {
        loading.classList.add('hidden');
      }
    }
    
    async function downloadChartDirect(chartElement, chartId, format) {
      const timestamp = new Date().toISOString().slice(0,10).replace(/-/g, '');
      const filename = `AthleteTime_장호준코치제작_${chartId}_${timestamp}`;
      
      // 컨테이너 생성
      const container = document.createElement('div');
      container.style.cssText = 'position: absolute; left: -9999px; width: 1200px; background: white; padding: 40px;';
      
      // 차트 복사
      const clone = document.importNode(chartElement, true);
      clone.querySelectorAll('.download-btn, .no-print').forEach(el => el.remove());
      container.appendChild(clone);
      
      document.body.appendChild(container);
      
      try {
        const canvas = await html2canvas(container, {
          scale: 2,
          backgroundColor: '#ffffff'
        });
        
        if (format === 'png') {
          canvas.toBlob(blob => {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = filename + '.png';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
          });
        } else if (format === 'pdf') {
          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF('l', 'mm', 'a4');
          const dataUrl = canvas.toDataURL('image/png');
          pdf.addImage(dataUrl, 'PNG', 10, 10, 277, 190);
          pdf.save(filename + '.pdf');
        }
      } finally {
        document.body.removeChild(container);
      }
    }
  </script>
</body>
</html>