<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>VDOT 공식 분석 및 비교</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="bg-gray-50 p-8">
  <div class="max-w-6xl mx-auto">
    <h1 class="text-3xl font-bold mb-8">🔬 VDOT 계산 공식 분석</h1>
    
    <!-- 공식 비교 -->
    <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
      <h2 class="text-xl font-bold mb-4 text-red-600">⚠️ 발견된 문제점</h2>
      
      <div class="grid md:grid-cols-2 gap-6">
        <!-- Daniels-Gilbert 실제 공식 -->
        <div class="bg-blue-50 p-4 rounded-lg">
          <h3 class="font-bold mb-3">📐 Daniels-Gilbert 원본 공식</h3>
          <div class="bg-white p-3 rounded font-mono text-sm mb-3">
            VO2max = (VO2) / (%VO2max)<br><br>
            VO2 = -4.60 + 0.182258 × v + 0.000104 × v²<br><br>
            %VO2max = 0.8 + 0.1894393 × e^(-0.012778×t) <br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ 0.2989558 × e^(-0.1932605×t)
          </div>
          <div class="text-sm text-gray-600">
            <p>• v = 속도 (m/min)</p>
            <p>• t = 시간 (분)</p>
            <p>• 연속적인 곡선 함수</p>
            <p>• 모든 거리에 적용 가능</p>
          </div>
        </div>
        
        <!-- 현재 테이블 방식 -->
        <div class="bg-orange-50 p-4 rounded-lg">
          <h3 class="font-bold mb-3">📊 현재 사용 중인 테이블 방식</h3>
          <div class="bg-white p-3 rounded font-mono text-sm mb-3">
            vdotTables = {<br>
            &nbsp;&nbsp;30: { 5000: 2680 },<br>
            &nbsp;&nbsp;35: { 5000: 2340 },<br>
            &nbsp;&nbsp;40: { 5000: 2070 },<br>
            &nbsp;&nbsp;...<br>
            }
          </div>
          <div class="text-sm text-gray-600">
            <p>• 고정된 VDOT 값 (5단위)</p>
            <p>• 특정 거리만 정의</p>
            <p>• 선형 보간 사용</p>
            <p class="text-red-600 font-bold">• 정확도 제한</p>
          </div>
        </div>
      </div>
    </div>

    <!-- 차이점 분석 -->
    <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
      <h2 class="text-xl font-bold mb-4">📈 계산 방식 차이 비교</h2>
      
      <canvas id="vdotChart" class="mb-4"></canvas>
      
      <div class="grid md:grid-cols-3 gap-4 mt-6">
        <div class="bg-red-50 p-4 rounded-lg">
          <h4 class="font-bold text-red-600 mb-2">문제 1: 정확도</h4>
          <p class="text-sm">테이블은 5 단위로만 존재<br>
          실제: VDOT 52.3 → 테이블: 50 또는 55</p>
        </div>
        <div class="bg-yellow-50 p-4 rounded-lg">
          <h4 class="font-bold text-yellow-600 mb-2">문제 2: 보간 오차</h4>
          <p class="text-sm">선형 보간 vs 지수 함수<br>
          중간값에서 최대 3-5% 오차</p>
        </div>
        <div class="bg-purple-50 p-4 rounded-lg">
          <h4 class="font-bold text-purple-600 mb-2">문제 3: 거리 제한</h4>
          <p class="text-sm">정의되지 않은 거리<br>
          (예: 3000m 장애물)</p>
        </div>
      </div>
    </div>

    <!-- 실제 계산기 -->
    <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
      <h2 class="text-xl font-bold mb-4">🔧 정확한 VDOT 계산기</h2>
      
      <div class="grid md:grid-cols-3 gap-4 mb-4">
        <div>
          <label class="block text-sm font-medium mb-1">거리 (m)</label>
          <input type="number" id="distance" value="5000" class="border rounded p-2 w-full">
        </div>
        <div>
          <label class="block text-sm font-medium mb-1">시간 (분:초)</label>
          <input type="text" id="time" value="20:00" placeholder="예: 20:00" class="border rounded p-2 w-full">
        </div>
        <div class="flex items-end">
          <button onclick="calculateExactVDOT()" class="bg-blue-500 text-white px-6 py-2 rounded w-full">
            정확한 VDOT 계산
          </button>
        </div>
      </div>
      
      <div id="comparisonResult"></div>
    </div>

    <!-- 오차 분석 -->
    <div class="bg-white rounded-xl shadow-lg p-6">
      <h2 class="text-xl font-bold mb-4">📊 오차 분석 결과</h2>
      
      <div class="overflow-x-auto">
        <table class="w-full text-sm">
          <thead>
            <tr class="bg-gray-100">
              <th class="p-2">거리</th>
              <th class="p-2">기록</th>
              <th class="p-2">정확한 VDOT</th>
              <th class="p-2">테이블 VDOT</th>
              <th class="p-2">오차</th>
              <th class="p-2">영향</th>
            </tr>
          </thead>
          <tbody id="errorAnalysis"></tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    // Daniels-Gilbert 정확한 공식
    function calculateExactVDOTFormula(distanceMeters, timeSeconds) {
      const velocity = distanceMeters / (timeSeconds / 60); // m/min
      const time = timeSeconds / 60; // minutes
      
      // VO2 계산 (산소 소비량)
      const vo2 = -4.60 + 0.182258 * velocity + 0.000104 * Math.pow(velocity, 2);
      
      // %VO2max 계산 (지속 가능한 비율)
      const percentVO2max = 0.8 + 
        0.1894393 * Math.exp(-0.012778 * time) + 
        0.2989558 * Math.exp(-0.1932605 * time);
      
      // VDOT = VO2 / %VO2max
      const vdot = vo2 / percentVO2max;
      
      return vdot;
    }
    
    // 현재 테이블 방식 (간소화)
    const vdotTables = {
      30: { 800: 316, 1500: 681, 3000: 1520, 5000: 2680, 10000: 5560 },
      35: { 800: 279, 1500: 598, 3000: 1330, 5000: 2340, 10000: 4860 },
      40: { 800: 249, 1500: 532, 3000: 1178, 5000: 2070, 10000: 4290 },
      45: { 800: 224, 1500: 477, 3000: 1053, 5000: 1845, 10000: 3825 },
      50: { 800: 203, 1500: 431, 3000: 948, 5000: 1658, 10000: 3435 },
      55: { 800: 185, 1500: 392, 3000: 859, 5000: 1500, 10000: 3105 },
      60: { 800: 169, 1500: 357, 3000: 781, 5000: 1362, 10000: 2820 },
      65: { 800: 155, 1500: 327, 3000: 713, 5000: 1242, 10000: 2565 },
      70: { 800: 143, 1500: 301, 3000: 654, 5000: 1137, 10000: 2346 },
      75: { 800: 132, 1500: 277, 3000: 601, 5000: 1044, 10000: 2154 },
      80: { 800: 122, 1500: 256, 3000: 554, 5000: 961, 10000: 1983 }
    };
    
    function calculateTableVDOT(distanceMeters, timeSeconds) {
      let closestVDOT = 30;
      let minDiff = Infinity;
      
      for (const [vdot, times] of Object.entries(vdotTables)) {
        if (times[distanceMeters]) {
          const diff = Math.abs(times[distanceMeters] - timeSeconds);
          if (diff < minDiff) {
            minDiff = diff;
            closestVDOT = parseInt(vdot);
          }
        }
      }
      
      // 선형 보간
      const vdotKeys = Object.keys(vdotTables).map(v => parseInt(v)).sort((a, b) => a - b);
      for (let i = 0; i < vdotKeys.length - 1; i++) {
        const lowerVDOT = vdotKeys[i];
        const upperVDOT = vdotKeys[i + 1];
        
        if (vdotTables[lowerVDOT][distanceMeters] && vdotTables[upperVDOT][distanceMeters]) {
          const lowerTime = vdotTables[lowerVDOT][distanceMeters];
          const upperTime = vdotTables[upperVDOT][distanceMeters];
          
          if (timeSeconds <= lowerTime && timeSeconds >= upperTime) {
            const ratio = (lowerTime - timeSeconds) / (lowerTime - upperTime);
            closestVDOT = lowerVDOT + (upperVDOT - lowerVDOT) * ratio;
            break;
          }
        }
      }
      
      return Math.round(closestVDOT * 10) / 10;
    }
    
    function parseTime(timeStr) {
      const parts = timeStr.split(':').map(p => parseInt(p));
      if (parts.length === 2) {
        return parts[0] * 60 + parts[1];
      }
      return 0;
    }
    
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    function calculateExactVDOT() {
      const distance = parseFloat(document.getElementById('distance').value);
      const timeStr = document.getElementById('time').value;
      const timeSeconds = parseTime(timeStr);
      
      if (!distance || !timeSeconds) {
        alert('거리와 시간을 입력하세요');
        return;
      }
      
      const exactVDOT = calculateExactVDOTFormula(distance, timeSeconds);
      const tableVDOT = calculateTableVDOT(distance, timeSeconds);
      const difference = exactVDOT - tableVDOT;
      const percentError = (difference / exactVDOT) * 100;
      
      const html = `
        <div class="grid md:grid-cols-2 gap-4 mt-4">
          <div class="bg-green-50 p-4 rounded-lg">
            <h4 class="font-bold text-green-600">정확한 공식 계산</h4>
            <div class="text-2xl font-bold mt-2">${exactVDOT.toFixed(2)}</div>
            <div class="text-sm text-gray-600 mt-2">
              <p>속도: ${(distance / (timeSeconds / 60)).toFixed(1)} m/min</p>
              <p>VO2: ${(-4.60 + 0.182258 * (distance / (timeSeconds / 60)) + 0.000104 * Math.pow(distance / (timeSeconds / 60), 2)).toFixed(2)} ml/kg/min</p>
            </div>
          </div>
          <div class="bg-orange-50 p-4 rounded-lg">
            <h4 class="font-bold text-orange-600">테이블 방식 계산</h4>
            <div class="text-2xl font-bold mt-2">${tableVDOT.toFixed(1)}</div>
            <div class="text-sm text-gray-600 mt-2">
              <p class="${Math.abs(difference) > 1 ? 'text-red-600 font-bold' : ''}">
                오차: ${difference > 0 ? '+' : ''}${difference.toFixed(2)} (${percentError.toFixed(1)}%)
              </p>
              <p>${Math.abs(difference) > 1 ? '⚠️ 상당한 오차 발생!' : '✅ 허용 범위 내'}</p>
            </div>
          </div>
        </div>
        
        ${Math.abs(difference) > 1 ? `
        <div class="bg-red-50 border-l-4 border-red-400 p-4 mt-4 rounded">
          <h4 class="font-bold text-red-600 mb-2">🚨 오차로 인한 영향</h4>
          <div class="text-sm">
            <p>• 잘못된 훈련 페이스: 약 ${Math.abs(difference * 2).toFixed(0)}초/km 차이</p>
            <p>• 부정확한 목표 설정: ${Math.abs(percentError).toFixed(1)}% 오차</p>
            <p>• ${difference > 0 ? '과소평가된 능력 (너무 쉬운 훈련)' : '과대평가된 능력 (너무 힘든 훈련)'}</p>
          </div>
        </div>` : ''}
      `;
      
      document.getElementById('comparisonResult').innerHTML = html;
    }
    
    // 차트 그리기
    function drawComparisonChart() {
      const ctx = document.getElementById('vdotChart').getContext('2d');
      
      // 5000m 기준 데이터 생성
      const times = [];
      const exactVDOTs = [];
      const tableVDOTs = [];
      
      for (let seconds = 900; seconds <= 2100; seconds += 60) { // 15분 ~ 35분
        times.push(formatTime(seconds));
        exactVDOTs.push(calculateExactVDOTFormula(5000, seconds));
        tableVDOTs.push(calculateTableVDOT(5000, seconds));
      }
      
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: times,
          datasets: [{
            label: '정확한 공식',
            data: exactVDOTs,
            borderColor: 'rgb(34, 197, 94)',
            backgroundColor: 'rgba(34, 197, 94, 0.1)',
            tension: 0.4
          }, {
            label: '테이블 방식',
            data: tableVDOTs,
            borderColor: 'rgb(251, 146, 60)',
            backgroundColor: 'rgba(251, 146, 60, 0.1)',
            tension: 0.1,
            borderDash: [5, 5]
          }]
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: '5000m 기록별 VDOT 계산 비교'
            },
            legend: {
              position: 'top',
            }
          },
          scales: {
            y: {
              title: {
                display: true,
                text: 'VDOT'
              }
            },
            x: {
              title: {
                display: true,
                text: '5000m 기록'
              }
            }
          }
        }
      });
    }
    
    // 오차 분석 테이블
    function analyzeErrors() {
      const testCases = [
        { distance: 800, time: 150, desc: '800m 2:30' },
        { distance: 1500, time: 270, desc: '1500m 4:30' },
        { distance: 3000, time: 600, desc: '3000m 10:00' },
        { distance: 5000, time: 1110, desc: '5000m 18:30' },
        { distance: 10000, time: 2400, desc: '10000m 40:00' },
        { distance: 21097.5, time: 5400, desc: '하프 1:30:00' },
        { distance: 42195, time: 12600, desc: '풀마라톤 3:30:00' }
      ];
      
      let html = '';
      testCases.forEach(test => {
        const exactVDOT = calculateExactVDOTFormula(test.distance, test.time);
        const tableVDOT = calculateTableVDOT(test.distance, test.time);
        const difference = exactVDOT - tableVDOT;
        const percentError = (difference / exactVDOT) * 100;
        
        const impact = Math.abs(percentError) > 3 ? '높음' : 
                      Math.abs(percentError) > 1 ? '중간' : '낮음';
        const impactColor = impact === '높음' ? 'text-red-600' : 
                           impact === '중간' ? 'text-yellow-600' : 'text-green-600';
        
        html += `
          <tr class="border-b hover:bg-gray-50">
            <td class="p-2">${test.desc.split(' ')[0]}</td>
            <td class="p-2">${test.desc.split(' ')[1]}</td>
            <td class="p-2 font-bold">${exactVDOT.toFixed(2)}</td>
            <td class="p-2">${tableVDOT.toFixed(1)}</td>
            <td class="p-2 ${Math.abs(percentError) > 3 ? 'text-red-600 font-bold' : ''}">
              ${percentError > 0 ? '+' : ''}${percentError.toFixed(1)}%
            </td>
            <td class="p-2 ${impactColor} font-bold">${impact}</td>
          </tr>
        `;
      });
      
      document.getElementById('errorAnalysis').innerHTML = html;
    }
    
    // 초기화
    window.addEventListener('DOMContentLoaded', () => {
      drawComparisonChart();
      analyzeErrors();
      calculateExactVDOT(); // 기본값으로 계산
    });
  </script>
</body>
</html>